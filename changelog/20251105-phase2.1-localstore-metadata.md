# Phase 2.1: LocalStore Metadata Storage Implementation

**Date:** 2025-11-05
**Phase:** Phase 2.1 of KeyPackage Pool Implementation
**Status:** In Progress

## Task Specification

Implement the LocalStore metadata storage layer for KeyPackage pool management as specified in `changelog/20251105-keypackage-pool-implementation-plan-openmls-aligned.md`.

### Requirements
1. Add `keypackage_pool_metadata` table to LocalStore schema
2. Implement 8 CRUD and query methods for pool metadata
3. Add comprehensive unit tests
4. Ensure no regression in existing identity storage tests

### Scope
- **Files to modify:**
  - `client/rust/src/storage.rs` - Add table schema and all methods
  - `client/rust/tests/storage_tests.rs` - Create new test file with comprehensive tests

## High-Level Decisions

### Architecture Decision: Metadata-Only Storage
- LocalStore will store ONLY metadata about KeyPackages
- Actual KeyPackageBundle storage is handled by OpenMLS StorageProvider
- This avoids data duplication and aligns with OpenMLS architecture
- Storage savings: ~100-150 bytes per key vs. ~400-500 bytes if we stored full bundles

### Data Structure Design
- Primary key: `keypackage_ref` (BLOB) - references KeyPackage in OpenMLS storage
- Status lifecycle: created → uploaded → available → reserved → spent | expired
- Timestamps track each lifecycle transition
- Server-side metadata: reservation_id, reserved_by, spent_by, spent_group_id

### Indexing Strategy
- Index on `status` - frequent queries by status
- Index on `not_after` - expiry cleanup queries
- Index on `created_at` - chronological ordering

## Requirements Changes
None - implementing as originally specified in the plan.

## Files Modified

### `/home/kena/src/quintessence/mls-chat/client/rust/src/storage.rs`
**Changes:**
1. Add `KeyPackageMetadata` struct definition (public)
2. Add table creation SQL in `initialize()` method
3. Implement 8 new methods:
   - `create_pool_metadata()`
   - `update_pool_metadata_status()`
   - `count_by_status()`
   - `get_expired_refs()`
   - `get_metadata_by_status()`
   - `delete_pool_metadata()`
   - `update_reservation_info()`
   - `mark_spent()`

### `/home/kena/src/quintessence/mls-chat/client/rust/tests/storage_tests.rs`
**Changes:**
1. Create new test file
2. Add unit tests for:
   - Table initialization
   - CRUD operations (create, read, update, delete)
   - Count by status
   - Expiry queries
   - Status transitions
   - Reservation and spend operations
   - Edge cases (missing records, invalid data)

## Rationales and Alternatives

### Why metadata-only storage?
- **Alternative:** Store full KeyPackageBundle in LocalStore
- **Chosen:** Metadata-only storage
- **Rationale:**
  - Avoids data duplication (~40% storage savings)
  - Single source of truth (OpenMLS StorageProvider)
  - Aligns with OpenMLS architecture and forward-secrecy guarantees
  - Simpler deletion logic (no need to sync two copies)

### Why use INTEGER for timestamps?
- **Alternative:** TEXT with RFC3339 format
- **Chosen:** INTEGER (Unix epoch seconds)
- **Rationale:**
  - Efficient comparisons for expiry queries
  - Smaller storage footprint
  - Standard for time-based queries in SQLite
  - Matches OpenMLS KeyPackage lifetime format (u64)

### Why include server-side fields in metadata?
- **Alternative:** Store reservation/spend info only on server
- **Chosen:** Include in client metadata
- **Rationale:**
  - Enables offline diagnostics
  - Faster local queries (no API call needed)
  - Helps detect sync issues between client and server
  - Minimal storage overhead

## Obstacles and Solutions

### Obstacle 1: storage_tests.rs doesn't exist
- **Solution:** Create new test file following existing test patterns

### Obstacle 2: Need to understand existing error handling patterns
- **Solution:** Reviewed storage.rs and saw it uses `crate::error::Result`

## Current Status

### Completed
- [x] Read and understood the implementation plan
- [x] Read existing storage.rs structure
- [x] Created changelog file
- [x] Add KeyPackageMetadata struct definition (lines 14-44 in storage.rs)
- [x] Add table creation SQL (lines 72-93 in storage.rs)
- [x] Implement 8 CRUD/query methods (lines 126-306 in storage.rs)
- [x] Create storage_tests.rs (20 comprehensive tests)
- [x] Write comprehensive unit tests
- [x] Run tests and ensure they pass (20/20 passing)
- [x] Run `cargo test --lib` to check for regressions (71/71 passing, no regressions)

### Implementation Summary

**File: `/home/kena/src/quintessence/mls-chat/client/rust/src/storage.rs`**
- Added KeyPackageMetadata struct (lines 14-44)
- Added keypackage_pool_metadata table and indexes (lines 72-93)
- Implemented 8 methods:
  1. `create_pool_metadata()` - lines 132-148
  2. `update_pool_metadata_status()` - lines 153-177
  3. `count_by_status()` - lines 180-187
  4. `get_expired_refs()` - lines 192-203
  5. `get_metadata_by_status()` - lines 206-234
  6. `delete_pool_metadata()` - lines 237-243
  7. `update_reservation_info()` - lines 248-275
  8. `mark_spent()` - lines 280-305

**File: `/home/kena/src/quintessence/mls-chat/client/rust/tests/storage_tests.rs`**
- Created new integration test file
- 20 comprehensive tests covering:
  - Identity storage (verify no regression)
  - Pool metadata CRUD operations
  - Status transitions and counting
  - Expiry detection
  - Reservation and spend tracking
  - Full lifecycle test
  - Edge cases

### Test Results

All tests passing:
```
cargo test --test storage_tests
test result: ok. 20 passed; 0 failed

cargo test --lib
test result: ok. 71 passed; 0 failed
```

No regressions in existing functionality.

## Implementation Notes

### Method Signatures (from plan)
```rust
pub fn create_pool_metadata(&self, keypackage_ref: &[u8], not_after: i64) -> Result<()>
pub fn update_pool_metadata_status(&self, keypackage_ref: &[u8], status: &str) -> Result<()>
pub fn count_by_status(&self, status: &str) -> Result<usize>
pub fn get_expired_refs(&self, current_time: i64) -> Result<Vec<Vec<u8>>>
pub fn get_metadata_by_status(&self, status: &str) -> Result<Vec<KeyPackageMetadata>>
pub fn delete_pool_metadata(&self, keypackage_ref: &[u8]) -> Result<()>
pub fn update_reservation_info(&self, keypackage_ref: &[u8], reservation_id: &str, reserved_by: &str, expires_at: i64) -> Result<()>
pub fn mark_spent(&self, keypackage_ref: &[u8], spent_by: &str, group_id: &[u8]) -> Result<()>
```

### Test Coverage Targets
- Basic CRUD operations
- Status transitions (created → uploaded → available → reserved → spent)
- Expiry detection (keys with not_after < current_time)
- Count queries (count_by_status for each status)
- Reservation tracking
- Spend tracking
- Edge cases (nonexistent keys, invalid status values)

## Success Criteria
- [ ] All 8 methods implemented
- [ ] KeyPackageMetadata struct defined
- [ ] All unit tests pass
- [ ] No regression in existing identity storage tests
- [ ] Code follows existing patterns in storage.rs
- [ ] Proper error handling throughout
